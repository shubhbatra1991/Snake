{"ast":null,"code":"import { useEffect, useState } from 'react';\nfunction useIntersectionObserver(elementRef, _ref) {\n  let {\n    threshold = 0,\n    root = null,\n    rootMargin = '0%',\n    freezeOnceVisible = false\n  } = _ref;\n  const [entry, setEntry] = useState();\n  const frozen = (entry === null || entry === void 0 ? void 0 : entry.isIntersecting) && freezeOnceVisible;\n  const updateEntry = _ref2 => {\n    let [entry] = _ref2;\n    setEntry(entry);\n  };\n  useEffect(() => {\n    const node = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n    const hasIOSupport = !!window.IntersectionObserver;\n    if (!hasIOSupport || frozen || !node) return;\n    const observerParams = {\n      threshold,\n      root,\n      rootMargin\n    };\n    const observer = new IntersectionObserver(updateEntry, observerParams);\n    observer.observe(node);\n    return () => observer.disconnect();\n  }, [elementRef === null || elementRef === void 0 ? void 0 : elementRef.current, JSON.stringify(threshold), root, rootMargin, frozen]);\n  return entry;\n}\nexport default useIntersectionObserver;","map":{"version":3,"names":["useEffect","useState","useIntersectionObserver","elementRef","_ref","threshold","root","rootMargin","freezeOnceVisible","entry","setEntry","frozen","isIntersecting","updateEntry","_ref2","node","current","hasIOSupport","window","IntersectionObserver","observerParams","observer","observe","disconnect","JSON","stringify"],"sources":["/home/saurabh/Documents/Snake/node_modules/usehooks-ts/dist/esm/useIntersectionObserver/useIntersectionObserver.js"],"sourcesContent":["import { useEffect, useState } from 'react';\nfunction useIntersectionObserver(elementRef, { threshold = 0, root = null, rootMargin = '0%', freezeOnceVisible = false, }) {\n    const [entry, setEntry] = useState();\n    const frozen = (entry === null || entry === void 0 ? void 0 : entry.isIntersecting) && freezeOnceVisible;\n    const updateEntry = ([entry]) => {\n        setEntry(entry);\n    };\n    useEffect(() => {\n        const node = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n        const hasIOSupport = !!window.IntersectionObserver;\n        if (!hasIOSupport || frozen || !node)\n            return;\n        const observerParams = { threshold, root, rootMargin };\n        const observer = new IntersectionObserver(updateEntry, observerParams);\n        observer.observe(node);\n        return () => observer.disconnect();\n    }, [elementRef === null || elementRef === void 0 ? void 0 : elementRef.current, JSON.stringify(threshold), root, rootMargin, frozen]);\n    return entry;\n}\nexport default useIntersectionObserver;\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC3C,SAASC,uBAAuBA,CAACC,UAAU,EAAAC,IAAA,EAAiF;EAAA,IAA/E;IAAEC,SAAS,GAAG,CAAC;IAAEC,IAAI,GAAG,IAAI;IAAEC,UAAU,GAAG,IAAI;IAAEC,iBAAiB,GAAG;EAAO,CAAC,GAAAJ,IAAA;EACtH,MAAM,CAACK,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAC,CAAC;EACpC,MAAMU,MAAM,GAAG,CAACF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACG,cAAc,KAAKJ,iBAAiB;EACxG,MAAMK,WAAW,GAAGC,KAAA,IAAa;IAAA,IAAZ,CAACL,KAAK,CAAC,GAAAK,KAAA;IACxBJ,QAAQ,CAACD,KAAK,CAAC;EACnB,CAAC;EACDT,SAAS,CAAC,MAAM;IACZ,MAAMe,IAAI,GAAGZ,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACa,OAAO;IACvF,MAAMC,YAAY,GAAG,CAAC,CAACC,MAAM,CAACC,oBAAoB;IAClD,IAAI,CAACF,YAAY,IAAIN,MAAM,IAAI,CAACI,IAAI,EAChC;IACJ,MAAMK,cAAc,GAAG;MAAEf,SAAS;MAAEC,IAAI;MAAEC;IAAW,CAAC;IACtD,MAAMc,QAAQ,GAAG,IAAIF,oBAAoB,CAACN,WAAW,EAAEO,cAAc,CAAC;IACtEC,QAAQ,CAACC,OAAO,CAACP,IAAI,CAAC;IACtB,OAAO,MAAMM,QAAQ,CAACE,UAAU,CAAC,CAAC;EACtC,CAAC,EAAE,CAACpB,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACa,OAAO,EAAEQ,IAAI,CAACC,SAAS,CAACpB,SAAS,CAAC,EAAEC,IAAI,EAAEC,UAAU,EAAEI,MAAM,CAAC,CAAC;EACrI,OAAOF,KAAK;AAChB;AACA,eAAeP,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}